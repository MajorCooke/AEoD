Class ACSConverter play
{
	static void ToggleDirectors(int on = 0, bool text = false)
	{
		AEoDHandler.SendNetworkEvent("ToggleDirectors", on, text);
	}
}

Class AEoDHandler : EventHandler
{
	enum CvarList
	{
		Game_Blood,
		Game_Doom,
		Game_Duke,
		Game_Heretic,
		Game_Hexen,
		Game_Hexen2,
		Game_HL,
		Game_HL2,
		Game_MM,
		Game_Powerslave,
		Game_Quake1,
		Game_Quake2,
		Game_Quake4,
		Game_SW,
		Extra_Dm64,
		Extra_Hellspawn,
		Extra_Joke,
		Extra_L4DMon,
		Extra_ROTT,
		
		GameCount = 10,
		ExtraCount = 5,
		TotalCount = GameCount + ExtraCount
	};
	
	bool DemonMorph;
	bool CvarsUpdated;
	bool DirectorsEnabled;
	DirectorBase L4DDirector;
	DirectorBase NormalDirector;
	int L4DIntensity, MonIntensity, DirDelay, GameMode, L4DDir, NorDir;
	
	//Array<uint8> SectorD;	
	transient Cvar 	Themes[TotalCount];
	transient Cvar 	CL4DIntensity, CMonIntensity, CDirDelay, CEnabled, CL4DDir, CNorDir,
					CGameMode;
	//transient Cvar DirCvar[3];
	
	
	void GetCvars()
	{
		/*
		static const String Cvars[] =
		{
			"user_Doom",
			"user_Blood",
			"user_Duke",
			"user_HL",
			"user_HL2",
			"user_Heretic",
			"user_Hexen",
			"user_Hexen2",
			"user_MM",
			"user_Powerslave",
			"user_Quake1",
			"user_Quake2",
			"user_Quake4",
			"user_SW",
			"user_Strife"
			//-------------- The rest below are extras, not themes.
			"user_Dm64", 
			"user_Hellspawn", 
			"user_Joke", 
			"user_L4DMon", 
			"user_ROTT" 
		};
		
		for (int i = 0; i < Themes.Size(); i++)
		{
			
		}
		*/
		if (!CGameMode)			CGameMode = Cvar.FindCvar("AEoDGameMode");
		if (!CL4DIntensity)		CL4DIntensity = Cvar.FindCvar("user_L4DIntensity");
		if (!CMonIntensity)		CMonIntensity = Cvar.FindCvar("user_MonIntensity");
		if (!CDirDelay)			CDirDelay = Cvar.FindCvar("DirectorDelay");
		if (!CNorDir)			CNorDir = Cvar.FindCvar("user_NorDir");
		if (!CL4DDir)			CL4DDir = Cvar.FindCvar("user_L4DDir");
		
		if (CL4DIntensity)		L4DIntensity = 		CL4DIntensity.GetInt();
		if (CMonIntensity)		MonIntensity = 		CMonIntensity.GetInt();
		if (CDirDelay)			DirDelay = 			CDirDelay.GetInt();
		if (CGameMode)			GameMode =			CGameMode.GetInt();
		if (CNorDir)			NorDir =			CNorDir.GetBool();
		if (CL4DDir)			L4DDir =			CL4DDir.GetBool();
	}
	
	override void OnRegister()
	{
		GetCvars();
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		if (!e.IsReopen)
		{
			let plr = players[0].mo;
			if (GameMode == 1)
			{
				L4DDirector =					TheDirectorL4D(Actor.Spawn("TheDirectorL4D", plr.pos));
				plr.A_GiveInventory("L4DDirToken");
			}
			else
			{
				if (NorDir)	NormalDirector = 	TheDirector(Actor.Spawn("TheDirector", plr.pos));
				if (L4DDir)	
				{
					L4DDirector =		TheDirectorL4D(Actor.Spawn("TheDirectorL4D", plr.pos));
					plr.A_GiveInventory("L4DDirToken");
				}
			}
			
			DirectorsEnabled = (NorDir || L4DDir);
		}
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{	
		if (e.Name == 'EndDemonMorph')
		{
			int num = e.Player;
			let plr = players[num].mo;
			
			if (plr)
			{
				let dm = DemonPlayerMorph(plr);
				if (dm)
				{
					dm.EndMorph();
				}
			}
		}
		else if (e.Name == 'ToggleDirectors' && !e.IsManual)
		{
			let plr = players[0].mo;
			if (plr)
			{
				bool good = (L4DDirector || NormalDirector);
				if (good)
				{
					Switch(e.Args[0])
					{
						Case 1:	// Enable
							if (!DirectorsEnabled)
							{
								if (e.Args[1])		Console.Printf("Directors Enabled");
								if (L4DDirector)	L4DDirector.Activate(null);
								if (NormalDirector)	NormalDirector.Activate(null);
								DirectorsEnabled = true;
							}
							break;
						Case -1: // Disable
							if (DirectorsEnabled)
							{
								if (e.Args[1])		Console.Printf("Directors Disabled");
								if (L4DDirector)	L4DDirector.Deactivate(null);
								if (NormalDirector)	NormalDirector.Deactivate(null);
								DirectorsEnabled = false;
							}
							break;
						Default: // Toggle
							if (DirectorsEnabled)
							{
								if (e.Args[1])		Console.Printf("Directors Disabled");
								if (L4DDirector)	L4DDirector.Deactivate(null);
								if (NormalDirector)	NormalDirector.Deactivate(null);
							}
							else
							{
								if (e.Args[1])		Console.Printf("Directors Enabled");
								if (L4DDirector)	L4DDirector.Activate(null);
								if (NormalDirector)	NormalDirector.Activate(null);
							}
							DirectorsEnabled = !DirectorsEnabled;
							break;
					}
				}
			}
		}
		else if (!e.IsManual)
		{
			
			if (e.Name == 'DemonMorphOn')
			{
				DemonMorph = true;
				int num = e.Player;
				let plr = players[num].mo;
				
				
				ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
				Actor mo;
				while (mo = Actor(it.Next()))
				{
					if (mo.bISMONSTER && mo.health > 0)
					{
						if (mo.CountInv("DemonMorphTranslationItem") 
							|| mo.Species == 'Director'
							|| mo.Species == 'AEoDSpawner')	continue;
						
						mo.A_GiveInventory("DemonMorphTranslationItem", 1);
					}
				}
			}
			else if (e.Name == 'DemonMorphOff')
			{
				//Console.Printf("Called");
				DemonMorph = false;
				ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
				Actor mo;
				while (mo = Actor(it.Next()))
				{
					let inv = Inventory(mo.FindInventory("DemonMorphTranslationItem"));
					if (inv)	
					{
						//Console.Printf("Attempting Destruction");
						inv.DepleteOrDestroy();
					}
				}
			}
		}
	}
	
	override void WorldUnloaded(WorldEvent e)
	{
		DemonMorph = CvarsUpdated = false;
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let plr = players[i].mo;
				if (plr)	plr.A_SetInventory("RemoveDirector",0);
			}
		}
	}
	
	override void WorldThingSpawned(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (mo is "DirectorBase")
		{
			// Do not allow more than one director of each type to spawn.
			if (mo is "TheDirectorL4D")
			{
				if (L4DDirector && mo != L4DDirector) 		mo.Destroy();
				else 				L4DDirector = TheDirectorL4D(mo);
			}
			else if (mo is "TheDirector")
			{
				if (NormalDirector && mo != NormalDirector)	mo.Destroy();
				else				NormalDirector = TheDirector(mo);
			}
		}
		else if (DemonMorph && mo)
		{	
			if (mo && mo.bISMONSTER && mo.health > 0)
			{
				mo.A_GiveInventory("DemonMorphTranslationItem", 1);
			}
		}
	}
	
	override void WorldThingRevived(WorldEvent e)
	{
		if (DemonMorph && e.Thing)
		{
			Actor mo = e.Thing;
			if (mo && mo.bISMONSTER)
			{
				mo.A_GiveInventory("DemonMorphTranslationItem", 1);
			}
		}
	}
}

Class DemonMorphTransToken : Inventory {}

Class DemonMorphTranslationItem : Inventory
{
	uint OldTranslation;
	uint CurrentTranslation;
	uint FriendlyTranslation;
	uint EnemyTranslation;
	bool wasFriendly;
	bool resurrecting;
	bool DestroyMe;
	bool restored;
	
	override bool TryPickup(in out Actor toucher)
	{
		if (!toucher || toucher.health < 1 || toucher.CountInv(GetClass()))
			return false;
		
		bool good = Super.TryPickup(toucher);
		if (good && toucher)
		{
			restored = false;
			OldTranslation = toucher.Translation;
			toucher.A_SetTranslation("DemonMorphAlly");
			FriendlyTranslation = toucher.Translation;
			toucher.A_SetTranslation("DemonMorphTarget");
			EnemyTranslation = toucher.Translation;
			
			if (toucher.bFRIENDLY)	{ toucher.A_SetTranslation("DemonMorphAlly"); wasFriendly = true; }
			else						toucher.A_SetTranslation("DemonMorphTarget");
			
			toucher.bBRIGHT = true;
			CurrentTranslation = toucher.Translation;
			//Console.Printf("Translation set");
		}
		return good;
	}
	
	//==========================================================================
	//
	// The tick function.
	//
	//==========================================================================
	override void DoEffect()
	{
		// Destroy the thinker if we no actor, or actor's dead.
		if (DestroyMe || !owner || owner.health < 1)
		{
			return DepleteOrDestroy();
		}
		
		// No point doing anything if invisible.
		if (owner.alpha <= 0 || owner.GetRenderStyle() <= 0 || 
			owner.bINVISIBLE || owner.bNOSECTOR)
			return Super.DoEffect();
		
		
		// Change the translation based on friendly or not.
		// Make sure not to record it by changing the base and current
		// at the same time.
		if (!wasFriendly && owner.bFRIENDLY)
		{
			owner.Translation = CurrentTranslation = FriendlyTranslation;
		}
		else if (wasFriendly && !owner.bFRIENDLY)
		{
			owner.Translation = CurrentTranslation = EnemyTranslation;
		}
		wasFriendly = owner.bFRIENDLY;
		
		// Should their translation change at any point, record it.
		if (owner.Translation != CurrentTranslation)
			OldTranslation = owner.Translation;
		
		// Then set it again, and done.
		owner.Translation = CurrentTranslation;
		owner.bBRIGHT = true;
		restored = false;
		Super.DoEffect();
	}
	//==========================================================================
	//
	// As of switching to inventory items, this actually works for
	// monsters that burst into fragments thanks to the special handling of
	// inventory items upon death.
	//
	// Why do we need all three of these functions? Simply put, calling a
	// function is very time critical. This ensures all corner cases are
	// covered and all escape paths are cut off, ensuring the gibs are
	// returned to normal.
	// 
	// For example, OwnerDied in the super function calls Destroy() which then
	// has to process some other stuff first. By this time it may be too late.
	// Because this is all processed in a virtual machine, this is one exception
	// to making a function call for doing the work. It may be tidier, but
	// call speed is imperative if we want things happening in the proper order.
	// 
	//==========================================================================
	override void OwnerDied()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.OwnerDied();
	}
	override void OnDestroy()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.OnDestroy();
	}
	override void DepleteOrDestroy()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.DepleteOrDestroy();
	}
}