Class SoulReaperBeam : Actor
{
	const minDist = 64 ** 2;
	const closestCon = 500 ** 2;
	int seekflags;
	
	Actor closest;
	double closestDist;
	bool skip;
	
	Default
	{
		Projectile;
		+SEEKERMISSILE
		+DONTREFLECT
		+FOILINVUL
		+HITTRACER
		+PAINLESS
		+SCREENSEEKER
		+DONTSPLASH
		+NOTIMEFREEZE
		+NODAMAGETHRUST 
		+CANNOTPUSH
		+EXTREMEDEATH
		Speed 4;
		Radius 4;
		Height 4;
		Damage 0;
		DamageType "SoulReaperPull";
		//MaxTargetRange 4
		RenderStyle "None";
	}
	
	override void OnDestroy()
	{
		if (skip)	
		{	Super.OnDestroy(); return; }
		
		if (tracer && tracer != target)
		{
			if (tracer && tracer.bSHOOTABLE && tracer.health > 0)
			{
				int dmg = random(1,2);
				Vector3 SoulPos = tracer.pos;
					SoulPos.z = pos.z;
					
				int ret = tracer.DamageMobj(self, target, dmg, "SoulReaperPull", DMG_FOILINVUL | DMG_THRUSTLESS);
				if (!tracer || tracer.health < 1)
				{
					let ms = tracer.Spawn("DMSoulMissile", SoulPos);
					if (ms)
					{
						ms.target = target;
						ms.master = master;
						ms.tracer = tracer;
					}
				}
			}
		}
		Super.OnDestroy();
	}
	
	override int SpecialMissileHit(Actor victim)
	{
		if (!victim || (victim.bSOLID && !victim.bSHOOTABLE))	return 1;
		return -1;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (target)	pitch = target.pitch;
	}
	
	void SpawnTrail()
	{
		//user_s = random(1,5)
		//user_r = random(0,359)
		//A_ChangeVelocity(0,cos(-user_r)*(user_s + frandom(0.1,0.5)),sin(user_r)*(user_s + frandom(0.1,0.5)),CVF_RELATIVE|CVF_REPLACE)
		int rng = random(1,3);
		for (int i = 0; i < rng; i++)
		{
			double s = frandom(1.0,5.0);
			double r = frandom(0,359);
			A_SpawnParticle("Green",SPF_FULLBRIGHT|SPF_RELATIVE|SPF_NOTIMEFREEZE,9,frandom(5.0, 8.0), 0, 0, 0, 0, 
				0,
				 cos(r) * (s + frandom(0.1, 0.5)) * 0.65,
				-sin(r) * (s + frandom(0.1, 0.5)) * 0.65);
		}
	}
	
	States
	{
	Spawn:
		TNT1 A 1 NoDelay 
		{
			skip = false;
			int maxTime = 100;
			closestDist = closestCon;
			closest = null;
			
			ThinkerIterator it = ThinkerIterator.Create("DMSoulFragment",STAT_SOULS);
			Actor mo;
			while (mo = Actor(it.Next()))
			{
				double dist = Distance3DSquared(mo);
				
				if (dist > closestDist)
					continue;
				
				if (!CheckSight(mo, SF_IGNOREVISIBILITY|SF_IGNOREWATERBOUNDARY))
					continue;
					
				closest = mo;
				closestDist = dist;
			}
			
			if (closest)
			{
				bTHRUACTORS = true;
				while (Distance3DSquared(closest) > minDist)
				{
					if (!closest || maxTime < 1)		
					{
						skip = true;
						Destroy(); 
						return;
					}
					if (maxTime % 5 == 0)
						SpawnTrail();
						//A_SpawnItemEx("SoulReaperBeamTrail",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);
					A_Face(closest,2,2,0,0,FAF_BOTTOM);
					
					A_Warp(DefPtr, cos(pitch) * speed, 0, -sin(pitch) * speed, 0, WARPF_NOCHECKPOSITION);
					maxTime--;
				}
				
				let ms = closest.Spawn("DMSoulMissile", closest.pos);
				if (ms)
				{
					ms.target = target;
					ms.tracer = tracer;
					ms.master = master;
					ms.translation = closest.translation;
					closest.Destroy();
				}
				skip = true;
			}
			else
			{
				while (maxTime > 0)
				{
					if (maxTime % 5 == 0)
					{
						//A_SpawnItemEx("SoulReaperBeamTrail",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);
						SpawnTrail();
						if (!tracer || tracer.health < 1) 
						{
							tracer = null;
							A_SeekerMissile(1,1,SMF_PRECISE|SMF_LOOK,256,4);
						}
					}
					
					if (tracer)	A_FaceTracer(2,2,0,0,FAF_MIDDLE);
					
					Vector3 move = (cos(pitch) * speed, 0, -sin(pitch) * speed);
					bool check1 = (!A_Warp(AAPTR_DEFAULT, move.x, 0, move.z, 0,0,"Null"));
					bool check2 = check1 || (tracer && Distance3DSquared(tracer) < minDist);
					
					if (check1 || check2)
					{
						A_FaceTracer(0,0);
						if (check1)
							A_CheckBlock("Null", CBF_SETTRACER|CBF_NOLINES, AAPTR_DEFAULT, move.x, 0, move.z);
						
						bNOINTERACTION = true;
						skip = (tracer == null);
						return;
					}
					
					maxTime--;
				}
			}
		}
		TNT1 A 1;
		Stop;
	Death:
		TNT1 A 1; // { skip = true; }
		Stop;
	Crash:
	XDeath:
		TNT1 A 1; // { skip = false; }
		Stop;
		
	}
}
/*
Class SoulReaperBeamTrail : Actor
{
	int user_s;
	int user_r;
	int user_t;
	Default
	{
		Projectile
		+NODAMAGE
		+NOINTERACTION
		+NOTIMEFREEZE
		+SEEKERMISSILE
		Translation "0:255=%[0,0,0]:[0,1,0]";
		RenderStyle "Add";
		Scale 0.05;
		Alpha 0.25;
		Speed 0;
	}
	States
	{
	Spawn:
		X099 A 0 NoDelay A_SetUserVar(user_t,tid)
		X099 A 0 Thing_ChangeTID(0,0)
		X099 A 0 A_SetUserVar(user_s,random(1,5))
		X099 A 0 A_SetUserVar(user_r,random(0,359))
		X099 A 0 A_JumpIf(user_t > 0,"Specialty")
		X099 A 0 A_SetScale(frandom(0.03,0.06))		
		X099 A 0 A_SpawnItemEx("SoulReaperBeamTrail",-4.5,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,1)
		X099 A 0 A_SpawnItemEx("SoulReaperBeamTrail",-2.5,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,1)
		X099 A 0 A_SeekerMissile(10,10,SMF_PRECISE)
		X099 A 0 A_SpawnItemEx("SoulReaperBeamTrail",2.5,0,0,0,0,0,0,SXF_NOCHECKPOSITION,0,1)
		Goto Looping
	Specialty:
		X099 A 0 A_SetScale(ScaleX*frandom(0.02,0.04))
	Looping:
		X099 A 0
		X099 A 1 Bright A_FadeOut(0.025)
		Wait
	}
}*/

extend class AEoDWeaponBase
{
	AEoDHandler Event;
}

extend class AEoDWeaponSlot10
{
	action int A_FireApocalypseSpray(
		int dmg, double distance = 1024, double fulldist = 256, double conesize = 55.0)
	{
		// Make sure there's a weapon first.
		Weapon weapon = player.ReadyWeapon;
		if (!weapon || !weapon.DepleteAmmo(weapon.bAltFire))	
			return 0;
			
		A_GunFlash();
		A_SetBlend("DarkRed",0.4,50);
		
		// Now, check the player's aiming methods.
		// 0 & 1 we don't care about.
		// 2 = Don't damage allies.
		// 3 = Don't damage non-monsters unless there aren't any.
		CVar CSmartAim = Cvar.GetCvar("sv_smartaim", player);
		int SmartAim = 0;
		if (CSmartAim)	SmartAim = CSmartAim.GetInt();
		int count = 0;
		
		// Convert the conesize, and set up an array for targets to damage.
		conesize = cos(conesize);
		Array<Actor> Targets;	
		Targets.Clear();
		
		// Iterate through all actors on STAT_DEFAULT.
		let it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
		Actor mo;
		while (mo = Actor(it.Next()))
		{
			if (!mo.bICECORPSE)
			{
				if (SmartAim > 1 && mo.bFRIENDLY && mo.bISMONSTER)
					continue; // Player wants to not hit friendlies.
				if ((mo.health < 1 || (!mo.bSHOOTABLE && !mo.bVULNERABLE)))
					continue; // Dead or not shootable.
			}
			double dist = Distance3DSquared(mo);
			if (dist >= (distance ** 2))
				continue; // Too far away.
				
			if (!CheckSight(mo, SF_IGNOREWATERBOUNDARY|SF_IGNOREVISIBILITY))
				continue; // Can't see it due to level blocking vision.
			
			Vector3 forw = ( cos(angle) * cos(pitch), sin(angle) * cos(pitch), -sin(pitch) );
			Vector3 offs = Vec2OffsetZ(0, 0, player.viewz);		// Account for the view height
			Vector3 epos = mo.Vec3Offset(0, 0, mo.height * 0.5);
			Vector3 diff = LevelLocals.Vec3Diff(offs, epos);	// Internally does v2 - v1.
			double dl = diff.Length();
			if (dl != 0.0)
			{
				double cone = (forw dot diff) / dl;
				if (cone <= conesize) // Outside 'conesize' degrees.
					continue;
			}
			Targets.Push(mo);
		}
		// Nothing to hit.
		if (Targets.Size() < 1)	return 0;
		
		// Check if the player wants to avoid hitting objects if monsters are
		// ripe for damaging, and remove all non-monsters.
		if (SmartAim > 2)
		{
			bool FoundMonsters = false;
			for (int i = 0; i < Targets.Size(); i++)
			{
				mo = Targets[i];
				if (!mo)	{	Targets.Delete(i); i--;	continue;	}
				if (!FoundMonsters && mo.bISMONSTER)
				{
					FoundMonsters = true;
					break;
				}
			}
			// Found some monsters. Remove non-monsters now.
			if (FoundMonsters)
			{
				for (int i = 0; i < Targets.Size(); i++)
				{
					mo = Targets[i];
					if (!mo || !mo.bISMONSTER)
					{
						Targets.Delete(i);
						i--;
					}
				}
			}
			Targets.ShrinkToFit();
			if (Targets.Size() < 1)	return 0;
		}
		
		// Now dish out the damage.
		for (int i = 0; i < Targets.Size(); i++)
		{
			mo = Targets[i];
			if (!mo)	continue;
			
			// Spawn the effect.
			let apoc = Actor.Spawn("ApocSprayPlayer", mo.pos, ALLOW_REPLACE);
			if (!apoc)	continue;
			apoc.Angle = AngleTo(apoc);
			
			// Similar to A_Explode's calculations. GetRadiusDamage will do the
			// distance falloff stuff for us and use the returned damage.
			int damage = GetRadiusDamage(mo, dmg, distance, fulldist);
			if (damage > 0)
			{	
				// Now take that damage and open up a can of Whoopie Goldass!
				mo.DamageMobj(apoc, self, damage, apoc.DamageType, DMG_FOILINVUL|DMG_USEANGLE, apoc.Angle);
				count++;
			}
		}
		Targets.Clear();
		return count;
	}
}