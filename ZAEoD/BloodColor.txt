//================================================================
//================================================================
//
//	6.X New Blood Effects
//
//================================================================
//================================================================

/*	Currently available blood colors based on what's been used:

	Primary Color		Darker Color
	----------------------------------
	AEPutridGreen		AEPutridGreenD2
	AELimeGreen			AELimeGreenD2
	AEDarkRed			AEDarkRedD2
	AEGreenYellow		AEGreenYellowD2
	AEPoo				AEPooD2
	Black				Black
	Blue 				darkblue
	Brown 				AEPooD2
	DarkGreen 			AEDarkGreenD2
	DarkRed				AEDarkRedD2
	DimGray				AEDimGreyD2
	Gold				AEGoldD2
	GreenYellow			AEGreenYellowD2
	Green				DarkGreen
	Grey				DarkGrey
	LightSlateGray		DarkSlateGrey
	Orange				DarkOrange
	Purple				DarkViolet
	SeaShell2			AESeaShell2D2
	Snow3				Snow4
	White				Grey
	Yellow				AEDarkYellowD2
	AEBatshitRainbow	AEBatshitRainbowD2

================================================================================
						How to add new blood colors
================================================================================
1.	Add the new colors if they're not already defined in AEoDdat.pk3 -> 
	X11R6RGB.txt. Name it "AE<Color>".
	
2.	Make a duplicate entry called "AE<Color>D2" and assign half the RGB values.
	D2 stands for 'divide by 2', or half the color.
	
3.	Add "Color_<NameOfBloodColor>" to the enum below.
	This is only needed for the name itself -- do not define one for the D2
	since it's just there for adding extra tidbits and variance.
	
	Find Step 4+ down below.
	
	if ((bloodcolor & 0xffffff) == color("Red"))
*/

//****************************************************************
//****************************************************************
//
//	v5 Old Blood Effects
//
//****************************************************************
//****************************************************************



Class NewBlood : Blood //replaces Blood  //Blood as in v5.03, kept for compatability
{
	Default
	{
		+DONTSPLASH
		+DONTBLAST
		+NOTELESTOMP
		+NOTONAUTOMAP
		Scale 0.15;
		Gravity 0.44;
		DistanceCheck "user_MaxDrawDistance";
	}
	States
	{
	Spawn:
		BLD1 A 1;
//		TNT1 AAA 0 A_SpawnItemEx("ExtraBlood",random(3,-3),random(3,-3),random(3,-3),0,0,0,0,1)
		TNT1 AAA 0 A_SpawnItemEx("ExtraBlood",random(3,-3),random(3,-3),random(3,-3),1,0,0,random(1,359),GibFlags);
		BLD1 ABCD 6;
		Stop;
	}
}

Class ExtraBlood : NewBlood
{
	Default
	{
		Scale 0.09;
	}
	States
	{
	Spawn:
		TNT1 A 0;
		BLD1 A 1 ThrustThingZ(0,random(5,12),0,1);
		BLD1 A 5;
		BLD1 ABCD 6;
		Stop;
	}
}

Class MCBloodSprite : Actor
{
	int user_t;
	Default
	{
		Projectile;
		+THRUACTORS
		+DONTSPLASH
		+NOTIMEFREEZE
		+NOTELESTOMP
		+NOTONAUTOMAP
		+PUFFGETSOWNER
		RenderStyle "Translucent";
		Radius 1;
		Height 1;
		Gravity 0.20;
		Scale 0.3;
		DistanceCheck "user_MaxDrawDistance";
	}
	States
	{
	Buffer:
		X057 ABCDEFGHIJKLMNOPQRS 0;
		XA57 ABCDEFGHIJKLMNOPQRS 0;
		XB57 ABCDEFGHIJKLMNOPQRS 0;
		XC57 ABCDEFGHIJKLMNOPQRS 0;
	Spawn:
		TNT1 A 0 NoDelay 
		{
			user_t = tid;
			Thing_ChangeTID(0,0);
			A_SetScale(Scale.X*randompick(-1,1),Scale.Y*randompick(-1,1));
			return A_Jump(256,"B1","B2","B3");
		}
	B11:
		"####" A 0
		{
			static const Name Spr[] =
			{
				"X057",
				"XA57",
				"XB57",
				"XC57"
			};
			sprite = GetSpriteIndex(Spr[random(0,3)]);
		}
		"####" ABCDEF 2 A_FadeOut(0.05);
		"####" GHIJK 1 A_FadeOut(0.05);
		"####" LMNOPQRS 1 A_FadeOut(0.03);
		Wait;
	B2:
		"####" A 0
		{
			static const Name Spr[] =
			{
				"X058",
				"XA58",
				"XB58",
				"XC58"
			};
			sprite = GetSpriteIndex(Spr[random(0,3)]);
		}
		"####" ABCDEF 2 A_FadeOut(0.05);
		"####" GHIJK 1 A_FadeOut(0.05);
		"####" LMNOPQR 1 A_FadeOut(0.03);
		Wait;
	
	B3:
		"####" A 0
		{
			static const Name Spr[] =
			{
				"X059",
				"XA59",
				"XB59",
				"XC59"
			};
			sprite = GetSpriteIndex(Spr[random(0,3)]);
		}
		"####" ABCD 2 A_FadeOut(0.03);
		"####" EFGHIJ 1 A_FadeOut(0.04);
		"####" KLM 1 A_FadeOut(0.05);
		Wait;
	}
}

enum bloodcolors//TIDs ONLY. DO NOT USE IN THE TRANSLATIONS PROPERTY.
{
	Color_NULL				= 0, //
	Color_Red				= Color_NULL,
	Color_LimeGreen			= 1,
	Color_DarkRed			= 2,
	Color_GreenYellow		= 3,
	Color_Poo				= 4,
	Color_PutridGreen		= 5,
	Color_Black				= 6,
	Color_Blue				= 7,
	Color_Brown				= 8,
	Color_DarkGreen			= 9,
	Color_DimGray			= 10,
	Color_DimGrey			= Color_DimGray, //because it can be spelled either way.
	Color_Gold				= 11,
	Color_Green				= 12,
	Color_Grey				= 13,
	Color_Gray				= Color_Grey,
	Color_LightSlateGray	= 14,
	Color_LightSlateGrey	= Color_LightSlateGray,
	Color_Orange			= 15,
	Color_Purple			= 16,
	Color_SeaShell2			= 17,
	Color_Snow3				= 18,
	Color_White				= 19,
	Color_Yellow			= 20,
	Color_BatShitRainbow	= 21,
	//STEP 3 RIGHT HERE.
};

//==============================================================================
//==============================================================================
//
// Globalized Gib Spawners
//
//==============================================================================
//==============================================================================

// The Base Spawner

Class GibSpawnerBase : Actor
{
	int user_t;
	bool simple;
	int Index;
	int Cap;
	int SpawnChance;				// Just for the sake of making things simple...
	Color Trans;
	Color P1;
	Vector3 Vel;
	double MulBy[2];
	double RAdd;
	
	Array<String> Gib;
	Array<Int> Amt;
	Array<int> SimpleGib;
	
	//--------------------------------------------------------------------------
	// PostBeginPlay
	//
	// Since we have no reason to even do anything else, take care of business 
	// go away.
	//--------------------------------------------------------------------------
	override void PostBeginPlay()
	{
		
		if (GetClass() == "GibSpawnerBase" || !CheckReqs())
		{	 return Destroy();	}
		
		Super.PostBeginPlay();
		RAdd = 8;
		MulBy[0] = 1;
		MulBy[1] = 2;
		
		Gib.Clear();
		Amt.Clear();
		Class<Actor> ngib = null;
		Int namt = 0;
		int simp = 0;
		
		ngib = Gib01; namt = Gam01; simp = Sim01;	if (ngib && namt > 0)	{	Gib.Push(Gib01);	Amt.Push(namt); SimpleGib.Push(simp);	}
		ngib = Gib02; namt = Gam02; simp = Sim02;	if (ngib && namt > 0)	{	Gib.Push(Gib02);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib03; namt = Gam03; simp = Sim03;	if (ngib && namt > 0)	{	Gib.Push(Gib03);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib04; namt = Gam04; simp = Sim04;	if (ngib && namt > 0)	{	Gib.Push(Gib04);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib05; namt = Gam05; simp = Sim05;	if (ngib && namt > 0)	{	Gib.Push(Gib05);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib06; namt = Gam06; simp = Sim06;	if (ngib && namt > 0)	{	Gib.Push(Gib06);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib07; namt = Gam07; simp = Sim07;	if (ngib && namt > 0)	{	Gib.Push(Gib07);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib08; namt = Gam08; simp = Sim08;	if (ngib && namt > 0)	{	Gib.Push(Gib08);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib09; namt = Gam09; simp = Sim09;	if (ngib && namt > 0)	{	Gib.Push(Gib09);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		ngib = Gib10; namt = Gam10; simp = Sim10;	if (ngib && namt > 0)	{	Gib.Push(Gib10);	Amt.Push(namt);	SimpleGib.Push(simp);	}
		
		if (Gib.Size() <= 0)	return Destroy();
		
		for (int i = 0; i < Gib.Size(); i++)
		{
			// If not flagged for simple spawning, don't spawn it if the spawners outside of view.
			if (simple && !SimpleGib[i])	continue;
			
			for (int j = 0; j < Amt[i]; j++)
			{
				ngib = Gib[i];
				if (!ngib)
				{
					Console.Printf(Gib[i]..": bad actor");
					continue;
				}
				let spawned = GibletBase(Spawn(ngib, pos));
				// The target is intentionally set to this
				if (spawned)	
				{	
					spawned.Pitch = Pitch;
					spawned.Angle = Angle;
					spawned.target = self; 
					spawned.master = master;
					spawned.tracer = tracer;
					spawned.A_ChangeVelocity(
						Vel.X * frandom(MulBy[0],MulBy[1]) + frandom(-RAdd,RAdd),
						Vel.Y * frandom(MulBy[0],MulBy[1]) + frandom(-RAdd,RAdd),
						Vel.Z * frandom(MulBy[0],MulBy[1]) + frandom(-RAdd,RAdd),
						CVF_REPLACE);
					if (target)	spawned.P1 = (target.bloodcolor & 0xffffff);
					else		spawned.P1 = Color(255, 255, 0, 0);
				}
			}
		}
		
		return Destroy();
	}
	
	//--------------------------------------------------------------------------
	// CheckReqs
	// Checks to see if the gib count map-wide is < Max(Soft)GibCount.
	// If greater than soft max and < hard max, reduce the number of gibs it'll
	// spawn. If > hard max, don't spawn at all.
	//--------------------------------------------------------------------------
	bool CheckReqs()
	{
		user_t = tid;
		Thing_ChangeTID(0,0);
		
		if (A_CheckSightOrRange(BloodDistanceLimit,"Null"))
		{
			simple = true;
		}
		
		int count = 0;
		int SoftGibMax = GetCvar("MaxSoftGibCount");
		int HardGibMax = GetCvar("MaxGibCount");
		
		ThinkerIterator it = ThinkerIterator.Create("GibletBase");
		Actor mo;
		
		while ((count < HardGibMax) && (mo = GibletBase(it.Next())))
		{
			count++;
			
			// Over the soft gib threshold.
			if (!simple && count >= SoftGibMax)
			{	simple = true;	}
			
		}
		// Too many gibs spawned.
		if (count >= HardGibMax)
		{	return false;	}
		
		return true;
	}
	
	String Gib01, Gib02, Gib03, Gib04, Gib05, Gib06, Gib07, Gib08, Gib09, Gib10;
	int Gam01, Gam02, Gam03, Gam04, Gam05, Gam06, Gam07, Gam08, Gam09, Gam10;
	bool Sim01, Sim02, Sim03, Sim04, Sim05, Sim06, Sim07, Sim08, Sim09, Sim10;
	
	property Gib1: Gib01, Gam01, Sim01;
	property Gib2: Gib02, Gam02, Sim02;
	property Gib3: Gib03, Gam03, Sim03;
	property Gib4: Gib04, Gam04, Sim04;
	property Gib5: Gib05, Gam05, Sim05;
	property Gib6: Gib06, Gam06, Sim06;
	property Gib7: Gib07, Gam07, Sim07;
	property Gib8: Gib08, Gam08, Sim08;
	property Gib9: Gib09, Gam09, Sim09;
	property Gib10: Gib10, Gam10, Sim10;
	
	Default
	{
		+NOTELESTOMP
		+NOTONAUTOMAP
		+NOINTERACTION
		RenderStyle "None";
		BloodColor "Red";
	}
	
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	}
}

//==============================================================================
// Giblet Bases for inheritance purposes.
//==============================================================================

Class GibletBase : Actor 
{ 
	int user_short;
	int user_time;
	int user_t;
	int user_w;
	int user_spawntrail;
	Color P1;
	Default 
	{
		Projectile;
		+THRUACTORS
		-NOLIFTDROP
		+NOTELEPORT
		+NOTELESTOMP
		+NOTONAUTOMAP
		+NOTRIGGER
		-NOGRAVITY
		+BOUNCEONWALLS
		+BOUNCEONFLOORS
		+DOOMBOUNCE
		Radius 6;
		Height 5;
		BounceFactor 0.45;
		DistanceCheck "user_MaxDrawDistance";
	}
	
	override void BeginPlay()
	{	
		user_spawntrail = GetCvar("SpawnBloodTrails");
		Super.BeginPlay();
	}
	
	override void PostBeginPlay()
	{
		user_t = tid;
		Thing_ChangeTID(0,0);
		if (user_t < GibTID)	{	user_w = user_t;	}
		else					{	user_w = user_t - GibTID;	}
		
		Super.PostBeginPlay();
	}
	
	void SpawnGibBloodTrail()
	{
		if (user_spawntrail && !A_CheckSightOrRange(BloodDistanceLimit,"Null"))
		{	
			A_FaceMovementDirection();
			let blood = MCBloodFXMain(Spawn("MCBloodFXMain",pos));
			if (blood)
			{
				blood.target = target;
				blood.master = master;
				blood.tracer = tracer;
				blood.pitch = pitch;
				blood.angle = angle;
				blood.vel = vel;
				blood.P1 = P1;
				
			}
		}
	}
}

//==============================================================================
//==============================================================================
// Blood
//==============================================================================
//==============================================================================

Class MCBloodFXMain : Actor replaces Blood
{
	const VelMul = 1.0;
	int user_t;
	int user_count;
	int user_inv;
	Color P1;
	Default
	{
		//+MISSILE
		+NOBLOCKMAP
		+THRUACTORS
		+NOTIMEFREEZE
		+DONTSPLASH
		+NOTELESTOMP
		+NOTONAUTOMAP
		+PUFFGETSOWNER
		+ALWAYSPUFF
		-ALLOWPARTICLES
		+NOINTERACTION
		+NOTELESTOMP
		+HITTRACER
		BloodColor "Red";
		RenderStyle "None";
		Radius 1;
		Height 1;
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (A_CheckSightOrRange(BloodDistanceLimit,"Null"))
		{	
			return Destroy();
		}
		user_t = tid;
		Thing_ChangeTID(0,0);
		A_FaceMovementDirection();
	}
	States
	{
	Spawn:
		// DO NOT REMOVE THESE. According to Graf, two tics are required in order
		// for some internal crap to process as P_SpawnBlood has a special priority.
		// So... LEAVE THESE IN AND DON'T TOUCH THEM.
		TNT1 AAA 0 ;
		Goto SpawnBlood;
	SpawnBlood:
		TNT1 A 0
		{
			user_inv = GetCvar("user_BloodSprites");
			if (user_inv <= 0 || user_inv >= 2)
			{
				let blood = MCBloodParticle(Spawn("MCBloodParticle",pos));
				if (blood)
				{	
					blood.angle = angle;
					blood.pitch = pitch;
					blood.target = target;
					blood.master = master;
					blood.tracer = tracer;
					blood.A_Warp(DefPtr,frandom(0,2),0,random(1,4),0,WARPF_NOCHECKPOSITION);
					blood.Vel = Vel;
					blood.P1 = P1;
					
					if (target)
					{
						if (target is "GibletBase")
						{
							let gib = GibletBase(target);
							if (gib)
								P1 = gib.P1;
						}
						else	P1 = (target.bloodcolor & 0xffffff);
						
					}
					else	P1 = (bloodcolor & 0xffffff);
					blood.P1 = P1;
				}
			}
			
			if (user_inv <= 0)
			{	Destroy();	}
		}
		TNT1 AAA 1 
		{
			
			if (user_inv >= 1)
			{	A_SpawnItemEx("MCBloodSprite",frandom(0,2),0,random(1,4),frandom(0,1.5),0,frandom(0.1,2.0),random(0,359),GibFlags|SXF_TRANSFERTRANSLATION,0);	}
			else
			{	return ResolveState("Null");	}
			return ResolveState(null);
		}
		Stop;
	}
}

Class MCBloodFXTrail : MCBloodFXMain
{
	States
	{
	SpawnBlood:
		TNT1 A 0
		{
			A_FaceMovementDirection();
			if (user_inv >= 1)
			{	A_SpawnItemEx("MCBloodSprite",frandom(0,2),0,random(1,4),frandom(0,1.5),0,frandom(0.1,2.0),random(0,359),GibFlags|SXF_TRANSFERTRANSLATION,0);	}
			if (user_inv <= 0 || user_inv >= 2)
			{
				let blood = MCBloodParticle(Spawn("MCBloodParticle",pos));
				if (blood)
				{	
					blood.angle = angle;
					blood.pitch = pitch;
					blood.target = target;
					blood.master = master;
					blood.tracer = tracer;
					blood.A_Warp(DefPtr,frandom(0,2),0,random(1,4),0,WARPF_NOCHECKPOSITION);
					blood.Vel = Vel;
					blood.P1 = P1;
					
					if (target)
					{
						if (target is "GibletBase")
						{
							let gib = GibletBase(target);
							if (gib)
								P1 = gib.P1;
						}
						else	P1 = (target.bloodcolor & 0xffffff);
						
					}
					else	P1 = (bloodcolor & 0xffffff);
					blood.P1 = P1;
				}
			}
		}
		Stop;
	} 
}

Class MCBloodParticle : Actor
{
	// Take note, enums are for integers only. Thus, flags and regular numbers
	// can fit inside them, but floats cannot.
	// Do not add color_ definitions here. The scope is inside the Class for a 
	// reason. To find out more on how enums work, see
	// http://zdoom.org/wiki/Constants#DECORATE_usage
	enum parameters
	{
		PFlag = SPF_RELATIVE,
		Lifetime = 		35,		//Self explanatory.
		Size1Min = 		10,		//Size of bigger particle
		Size1Max = 		20,
		Size2Min = 		5,		//Size of smaller particle
		Size2Max = 		10,
		AOff = 			15,		//Angle
		MaxCount1 =		5,		//Max number of big particles
		MaxCount2 =		15,		//Max number of smaller particles
		MaxCount3 =		MaxCount1 + MaxCount2,
	};
	//Ones without the '2' at the end are for the big particles.
	//Those with the '2' are for the small particles. The default is
	//just to copy them.
	const XOffMin1 = 		1.0;	const XOffMin2 = 		XOffMin1;
	const XOffMax1 = 		-1.0;	const XOffMax2 = 		XOffMax1;
	const XVelMin1 = 		0.5;	const XVelMin2 = 		XVelMin1;
	const XVelMax1 = 		3.0;	const XVelMax2 = 		XVelMax1;
	const XAccMin1 = 		-0.01;	const XAccMin2 = 		XAccMin1;
	const XAccMax1 = 		-0.01;	const XAccMax2 = 		XAccMax1;
	const ZOffMin1 = 		-1.0;	const ZOffMin2 = 		ZOffMin1;
	const ZOffMax1 = 		1.0;	const ZOffMax2 = 		ZOffMax1;
	const ZVelMin1 = 		-0.5;	const ZVelMin2 = 		ZVelMin1;
	const ZVelMax1 = 		2.5;	const ZVelMax2 = 		ZVelMax1;
	const ZAccMin1 = 		-0.36;	const ZAccMin2 = 		ZAccMin1;
	const ZAccMax1 = 		-0.48;	const ZAccMax2 = 		ZAccMax1;
	const StartAlpha1 =		1.0;	const StartAlpha2 =		StartAlpha1;
	const FadeMin1 =		0.04;	const FadeMin2 =		FadeMin1;
	const FadeMax1 =		0.06;	const FadeMax2 =		FadeMax1;
	const PitchOff =		5.0;
	// Multiplies the velocity of the gib-spawned blood by this much. 
	// Has no effect on bullet spawned blood, etc.
	const VelMul = 0.75;
	const YVelMul = VelMul;
	const VelAccel = -0.15;
	int user_t;
	int user_count;
	double user_vel;
	double user_angle;
	double user_pitch;
	Color P1;
	Color P2;
	Default
	{
		Projectile;
		+NOINTERACTION
		+THRUACTORS
		+DONTSPLASH
		+NOTIMEFREEZE
		+NOTELESTOMP
		+NOTONAUTOMAP
		+PUFFGETSOWNER
		RenderStyle "None";
		Radius 1;
		Height 1;
	}
	
	const arraySize = 19;
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		user_vel = sqrt((Vel.X * Vel.X) + (Vel.Y * Vel.Y)) * VelMul;
		user_pitch = pitch;
		user_angle = angle;
		
		user_t = tid;
		Thing_ChangeTID(0,0);
		
	}
	
	States
	{
	Spawn:
		TNT1 A 1 NoDelay
		{		
			/*
			if (target && !(target is "GibletBase"))
			{
				P1 = (target.bloodcolor & 0xffffff);
			}
			*/
			static const Color SecondaryColor[] =
			{
				"DarkRed",
				"AELimeGreenD2",
				"AEDarkRedD2",
				"AEGreenYellowD2",
				"AEPooD2",
				"AEPutridGreenD2",
				"Black",
				"DarkBlue",
				"AEPooD2",
				"AEDarkGreenD2",
				"AEDimGrayD2",
				"AEGoldD2",
				"DarkGreen",
				"DarkGrey",
				"DarkSlateGray",
				"DarkViolet",
				"AESeaShellD2",
				"Snow4",
				"Grey",
				"AEDarkYellowD2"
			};

			static const Color PrimaryColor[] =
			{
				"Red",
				"AELimeGreen",
				"AEDarkRed",
				"AEGreenYellow",
				"AEPoo",
				"AEPutridGreen",
				"Black",
				"Blue",
				"Brown",
				"DarkGreen",
				"DimGray",
				"Gold",	//11
				"Green",
				"Grey",
				"LightSlateGray",
				"Purple",
				"Seashell2",
				"Snow3",
				"White",
				"Yellow" // 19
			};
			
			for (int index = 0; index < arraySize; index++)
			{
				if (P1 == PrimaryColor[index])
				{
					P2 = SecondaryColor[index];
					break;
				}
			}
			while (user_count < MaxCount3)
			{
				if (random(0,1))	{ A_SpawnParticle(P1,	PFlag, Lifetime, random(Size1Min,Size1Max), frandom(-AOff, AOff), frandom(XOffMin1,XOffMax1), 0, frandom(ZOffMin1,ZOffMax1), (cos(-pitch) * user_vel) + (frandom(XVelMin1,XVelMax1)), frandom(XVelMin1,XVelMax1) * randompick(-1,1), (((sin(-pitch) * Vel.Z) * VelMul) + (frandom(-ZVelMax1,ZVelMax1)))/2, frandom(XAccMin1,XAccMax1), 0, frandom(ZAccMin1,ZAccMax1), StartAlpha1, frandom(FadeMin1,FadeMax1)); }
				else				{ A_SpawnParticle(P2,	PFlag, Lifetime, random(Size2Min,Size2Max), frandom(-AOff, AOff), frandom(XOffMin2,XOffMax2), 0, frandom(ZOffMin2,ZOffMax2), (cos(-pitch) * user_vel) + (frandom(XVelMin2,XVelMax2)), frandom(XVelMin2,XVelMax2) * randompick(-1,1), (((sin(-pitch) * Vel.Z) * VelMul) + (frandom(-ZVelMax2,ZVelMax2)))/2, frandom(XAccMin2,XAccMax2), 0, frandom(ZAccMin2,ZAccMax2), StartAlpha2, frandom(FadeMin2,FadeMax2)); }
				user_count += randompick(1,1,1,2,3);
			}
		}
		Stop;
	}
}


Class AEBloodLimeGreen 		: MCBloodFXMain	{}
Class AEBloodGreenYellow	: MCBloodFXMain	{}
Class AEBloodPoo			: MCBloodFXMain	{}
Class AEBloodPutridGreen 	: MCBloodFXMain	{}
Class AEBloodBlack			: MCBloodFXMain	{}
Class AEBloodBrown			: MCBloodFXMain	{}
Class AEBloodBlue			: MCBloodFXMain	{}
Class AEBloodDarkGreen 		: MCBloodFXMain	{}
Class AEBloodDimGray		: MCBloodFXMain	{}
Class AEBloodGold			: MCBloodFXMain	{}
Class AEBloodGreen 			: MCBloodFXMain	{}
Class AEBloodGrey 			: MCBloodFXMain	{}
Class AEBloodLightSlateGray : MCBloodFXMain	{}
Class AEBloodOrange 		: MCBloodFXMain	{}
Class AEBloodPurple			: MCBloodFXMain	{}
Class AEBloodSeaShell2		: MCBloodFXMain	{}
Class AEBloodSnow3 			: MCBloodFXMain	{}
Class AEBloodWhite 			: MCBloodFXMain	{}
Class AEBloodYellow 		: MCBloodFXMain	{}
Class AEBloodBatShitRainbow : MCBloodFXMain	{}


//It's going to be impossible to translate blood splatters via particles directly
//so just have it spawn the ordinary Class instead.
Class MCBloodSplatter : MCBloodSprite replaces BloodSplatter	{ }
Class GibBloodSmall : MCBloodFXTrail 				{}
Class GibBloodTrailMediumSize	: MCBloodFXTrail	{}

//==============================================================================
//==============================================================================

//==============================================================================
//==============================================================================

Class SmallGibDropper : GibSpawnerBase
{
	Default
	{
		GibSpawnerBase.Gib1 "HGib1Small", 1, 1;
		GibSpawnerBase.Gib2 "HGib2Small", 1, 0;
		GibSpawnerBase.Gib3 "HGib3Small", 1, 0;
	}
}

Class GibDropper : GibSpawnerBase
{
	Default
	{
		GibSpawnerBase.Gib1 "HGib1", 1, 1;
		GibSpawnerBase.Gib2 "HGib2", 1, 0;
		GibSpawnerBase.Gib3 "HGib3", 1, 0;
	}
}

Class QuakeGibDropper : GibSpawnerBase
{
	Default
	{
		GibSpawnerBase.Gib1 "Gib1", 1, 1;
		GibSpawnerBase.Gib2 "Gib2", 1, 0;
		GibSpawnerBase.Gib3 "GibTorso", 1, 0;
	}
	
	override void PostBeginPlay()
	{
		if (A_CheckSightOrRange(BloodDistanceLimit,"Null"))
		{
			return Super.PostBeginPlay();
		}
		int a1 = random(3,6);
		int a2 = random(1, a1 - 1);
		a2 = a1 - a2;
		
		Gam01 = a1;
		Gam02 = a2;
		Super.PostBeginPlay();
	}
}
Class QuakeSmallGibDropper : GibSpawnerBase
{
	Default
	{
		GibSpawnerBase.Gib1 "SmallGib1", 1, 1;
		GibSpawnerBase.Gib2 "SmallGib2", 1, 0;
		GibSpawnerBase.Gib3 "SmallGibTorso", 1, 0;
	}
	
	override void PostBeginPlay()
	{
		if (A_CheckSightOrRange(BloodDistanceLimit,"Null"))
		{
			return Super.PostBeginPlay();
		}
		int a1 = random(3,5);
		int a2 = random(1, a1 - 1);
		a2 = a1 - a2;
		
		Gam01 = a1;
		Gam02 = a2;
		Super.PostBeginPlay();
	}
}

Class BloodGibDropper : GibSpawnerBase
{
	Default
	{
		GibSpawnerBase.Gib1 "NewMeat", 2, 1;
		GibSpawnerBase.Gib2 "BloodGib1", 1, 0;
		GibSpawnerBase.Gib3 "BloodGib2", 1, 0;
		GibSpawnerBase.Gib4 "BloodGib3", 1, 0;
		GibSpawnerBase.Gib5 "BloodGib4", 1, 0;
	}
	
	override void PostBeginPlay()
	{
		if (A_CheckSightOrRange(BloodDistanceLimit,"Null"))
		{
			return Super.PostBeginPlay();
		}
		
		Gam01 = 6;
		Gam02 = random(1,3);
		Gam03 = random(1,3);
		Gam04 = random(1,3);
		Gam05 = random(1,3);
		Super.PostBeginPlay();
	}
	
	override void BeginPlay()
	{
		RAdd = 7;
		Super.BeginPlay();
	}
}

//==============================================================================
//==============================================================================
// The Gibs
//==============================================================================
//==============================================================================

//==============================================================================
//
//	A_TossGib with blood trails
//
//==============================================================================

Class NewMeat : GibletBase replaces Meat
{
	Default
	{
		Radius 6;
		Height 5;	
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			sprite = GetSpriteIndex("MEAT");
			frame = random(0,19);
		}
		//MEAT ABCDEFGHIJLKMNOPQRST 0 { return ResolveState("Play1"); }
	Play1:
		"####" "#" 2 
		{
			SpawnGibBloodTrail();
			StateLabel dest = null;
			
			user_time++;
			
			if (pos.z <= floorz || user_time >= 87)		
			{	
				dest = "Death";	
			}
			return ResolveState(dest);
		}
// when the gib crashes:
	md1:
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		"####" "#" 350 A_JumpIf(user_t >= GibTID,1);
		"####" "#" 1 A_FadeOut();
		Wait;
	}
}

//==============================================================================
//Hexen2 style Gibs
//==============================================================================


Class HGib1Small : GibletBase
{
	Default
	{
		BounceFactor 0.4;
		Speed 4;
		Scale 0.07;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay 
		{
			A_ChangeVelocity(0,0,random(3,15));
			return ResolveState("Play");
		}
	Play:
		GIB7 AABBCCDDEEFFGGHHIIJJKKLLMM 2 SpawnGibBloodTrail();
		Goto Death;
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB7 M random(300,400) A_JumpIf(user_t >= GibTID,1); //Skip the duration.
		GIB7 M 2 A_FadeOut();
		Wait;
	}
}


Class HGib1SmallMirr : HGib1Small
{
	Default
	{
		Speed 5;
	}
	States
	{
	Play:
		GIB7 NNOOPPQQRRSSTTUUVVWWXXYYZZ 2 SpawnGibBloodTrail();
		Goto Death;
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB7 Z random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB7 Z 2 A_FadeOut();
		Wait;
	}
}

Class HGib2Small : HGib1Small
{
	Default
	{
		Speed 6;
	}
	States
	{
	Play:
		GIB8 AABBCCDDEEFFGGHHIIJJKKLLMM 2 SpawnGibBloodTrail();
		Goto Death;
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB8 M random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB8 M 2 A_FadeOut();
		Wait;
	}
}

Class HGib2SmallMirr : HGib1Small
{
	Default
	{
		Speed 3;
	}
	States
	{
	Play:
		GIB8 NNOOPPQQRRSSTTUUVVWWXXYYZZ 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB8 Z random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB8 Z 2 A_FadeOut();
		Wait;
	}
}

Class HGib3Small : HGib1Small
{
	Default
	{
		Speed 2;
	}
	States
	{
	Play:
		GIB9 AABBCCDDEEFFGGHHIIJJKKLL 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB9 L random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB9 L 2 A_FadeOut();
		Wait;
	}
}

Class HGib3SmallMirr : HGib1Small
{
	Default
	{
		Speed 4;
	}
	States
	{
	Play:
		GIB8 NNOOPPQQRRSSTTUUVVWWXXYYZZ 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB9 Z random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB9 Z 2 A_FadeOut();
		Wait;
	}
}
   

//***************************************************
//***************************************************


Class HGib1 : GibletBase
{
	Default
	{
		BounceFactor 0.4;
		Speed 4;
		Scale 0.1;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay 
		{
			A_ChangeVelocity(0,0,random(5,18));
			return ResolveState("Play");
		}
	Play:
		GIB7 AABBCCDDEEFFGGHHIIJJKKLLMM 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB7 M random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB7 M 2 A_FadeOut();
		Wait;
	}
}
Class HGib1Mirr : HGib1
{
	Default
	{
		Speed 5;
	}
	States
	{
	Play:
		GIB7 NNOOPPQQRRSSTTUUVVWWXXYYZZ 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB7 Z random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB7 Z 2 A_FadeOut();
		Wait;
	}
}

Class HGib2 : HGib1
{
	Default
	{
		Speed 6;
	}
	States
	{
	Play:
		GIB8 AABBCCDDEEFFGGHHIIJJKKLLMM 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB8 M random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB8 M 2 A_FadeOut();
		Wait;
	}
}


Class HGib2Mirr : HGib1
{
	Default
	{
		Speed 5;
	}
	States
	{
	Play:
		GIB8 NNOOPPQQRRSSTTUUVVWWXXYYZZ 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB8 Z random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB8 Z 2 A_FadeOut();
		Wait;
	}
}

Class HGib3 : HGib1
{
	Default
	{
		Speed 6;
	}
	States
	{
	Play:
		GIB9 AABBCCDDEEFFGGHHIIJJKKLL 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB9 L random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB9 L 2 A_FadeOut();
		Wait;
	}
}

Class HGib3Mirr : HGib1
{
	Default
	{
		Speed 5;
	}
	States
	{
	Play:
		GIB9 MMNNOOPPQQRRSSTTUUVVWWXX 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		GIB9 X random(300,400) A_JumpIf(user_t >= GibTID,1);
		GIB9 X 2 A_FadeOut();
		Wait;
	}
}

//===============================================================================
//===============================================================================
//
//	Quake gibs
//
//===============================================================================
//===============================================================================

//***********************************
Class Gib1 : GibletBase
{
	Default
	{
		BounceFactor 0.45;
		Speed 8;
		Scale 0.34;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay 
		{
			A_ChangeVelocity(0,0,random(5,18));
			return ResolveState("Play");
		}
	Play:
		Q99B BBCCDDEEFFGGHHIIJJKKLLMMNN 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		Q99B N random(300,400) A_JumpIf(user_t >= GibTID,1);
		Q99B N 2 A_FadeOut();
		Wait;
	}
}

Class GibTorso : Gib1
{
	Default
	{
		Speed 2;
		Scale 0.31;
	}
	States
	{
	Play:
		Q99C AABBCCDDEEFF 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		Q99C F random(300,400) A_JumpIf(user_t >= GibTID,1);
		Q99C F 2 A_FadeOut();
		Wait;
	}
}

Class Gib2 : Gib1
{
	Default
	{
		Speed 5;
		Scale 0.26;
	}
	States
	{
	Play:
		Q99D AABBCCDDEE 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		Q99D F random(300,400) A_JumpIf(user_t >= GibTID,1);
		Q99D F 2 A_FadeOut();
		Wait;
	}
}

//==================================================================


//***********************************
Class SmallGib1 : Gib1
{
	Default
	{
		Speed 8;
		Scale 0.27;
	}
	States
	{
	Play:
		Q99B BBCCDDEEFFGGHHIIJJKKLLMMNN 2 SpawnGibBloodTrail();
		/*
		{
			if (user_spawntrail && !A_CheckSightOrRange(BloodDistanceLimit,"Null"))
			{	//A_FaceMovementDirection(); 
			A_SpawnItemEx("GibBloodSmall",0,0,0,Vel.X,Vel.Y,Vel.Z,0,SXF_ABSOLUTEVELOCITY|SXF_TRANSFERPITCH|SXF_TRANSFERTRANSLATION|SXF_USEBLOODCOLOR,0,user_w);	}
		} 
		*/
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		Q99B N 350 A_JumpIf(user_t >= GibTID,1);
		Q99B N 2 A_FadeOut();
		Wait;
	}
}

Class SmallGibTorso : SmallGib1 
{
	Default
	{
		Speed 2;
		Scale 0.23;
	}
	States
	{
	Play:
		Q99C AABBCCDDEEFF 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		Q99C F 380 A_JumpIf(user_t >= GibTID,1);
		Q99C F 2 A_FadeOut();
		Wait;
	}
}


Class SmallGib2 : SmallGib1 
{
	Default
	{
		Speed 5;
		Scale 0.19;
	}
	States
	{
	Play: //ThrustThingZ(0,random(10,60),0,1)
		Q99D AABBCCDDEE 2 SpawnGibBloodTrail();
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		Q99D F 366 A_JumpIf(user_t >= GibTID,1);
		Q99D F 2 A_FadeOut();
		Wait;
	}
}


//===============================================================================
//===============================================================================
//
//	Blood style gibs
//
//===============================================================================
//===============================================================================

//***************************************
Class BloodGib1 : GibletBase
{
	int user_c;
	Default
	{
		Scale 0.6;
		Radius 6;
		Height 5;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay 
		{
			ThrustThingZ(0,random(12,80),0,1);
			return ResolveState("Looping");
		}
	Looping:
		ANYG AABBCCDD 2 SpawnGibBloodTrail();
		"####" "#" 0 
		{
			user_c++;
			return A_JumpIf(user_c > 5,"Death");
		}
		Loop;
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		ANYG E random(300,600) A_JumpIf(user_t >= GibTID,1);
		ANYG E 1 A_FadeOut();
		Wait;
	}
}

Class BloodGib2 : BloodGib1		//eye
{
	Default
	{
		Scale 0.4;
		Speed 7;
	}
	States
	{
	Looping:
		ANYG FFGGHHII 2 SpawnGibBloodTrail();
		"####" "#" 0 
		{
			user_c++;
			return A_JumpIf(user_c > 5,"Death");
		}
		Loop;
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		ANYG J random(300,600) A_JumpIf(user_t >= GibTID,1);
		ANYG J 1 A_FadeOut();
		Wait;
	}
}

Class BloodGib3 : BloodGib1		//liver
{
	Default
	{
		Scale 0.6;
		Speed 7;
	}
	States
	{
	Looping:
		ANYG KKLLMMNN 2 SpawnGibBloodTrail();
		"####" "#" 0 
		{
			user_c++;
			return A_JumpIf(user_c > 5,"Death");
		}
		Loop;
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		ANYG O random(300,600) A_JumpIf(user_t >= GibTID,1);
		ANYG O 1 A_FadeOut();
		Wait;
	}
}

Class BloodGib4 : BloodGib1		//bloodthing
{
	Default
	{
		Scale 0.6;
		Speed 7;
	}
	States
	{
	Looping:
		ANYG PPQQRRSS 2 SpawnGibBloodTrail();
		"####" "#" 0 
		{
			user_c++;
			return A_JumpIf(user_c > 5,"Death");
		}
	Death:
		"####" "#" 0 A_JumpIf(GetCvar("user_ShortGibLives"),2);
		ANYG T random(300,600) A_JumpIf(user_t >= GibTID,1);
		ANYG T 1 A_FadeOut();
		Wait;
	}
}

//==============================================================================
//==============================================================================







//==============================================================================
//==============================================================================

Class GibletBaseSpawner : Actor 
{	
	Color P1;
	Default 
	{
		+NOTELESTOMP
		+NOTONAUTOMAP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
		Radius 1;
		Height 1;
		DistanceCheck "user_MaxDrawDistance";
	}
}

Class NewJunk : Junk replaces Junk
{
	Color P1;
	Default
	{
		+NOTELESTOMP
		+THRUACTORS
		+NOTONAUTOMAP
		DistanceCheck "user_MaxDrawDistance";
	}
}


//***********************************
Class GreenGib : GibletBaseSpawner
{
	Default
	{
		Translation "32:47=123:127", "169:191=112:127";
	}
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_CheckSight(2);
		TNT1 AA 0 A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
		Stop;
	Spawn2:
		TNT1 A 0 A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
		Stop;
	}
}

Class GreenGibSp : GreenGib
{
	Default
	{
		Translation "32:47=123:127", "169:191=112:127";
		BloodColor "Green";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_CheckSight("Spawn2");
		TNT1 AAAAAAAA 0 
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	Spawn2:
		TNT1 AA 0
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	}
}

//***********************************
Class BlueGib : GibletBaseSpawner
{
	Default
	{
		Translation "32:47=204:207", "169:191=196:205";
		BloodColor "Blue";
	}
	States
	{
	Spawn:
		TNT1 A 0 ;
		TNT1 A 0 A_CheckSight("Spawn2");
		TNT1 AA 0 A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
		Stop;
	Spawn2:
		TNT1 A 0;
		Stop;
	}
}

Class BlueGibSp : BlueGib
{
	Default
	{
		Translation "32:47=204:207", "169:191=196:205";
		BloodColor "Blue";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_CheckSight("Spawn2");
		TNT1 AAAAAAAA 0 
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	Spawn2:
		TNT1 AA 0
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	}
}


//***********************************
Class OrangeGib : GibletBaseSpawner
{
	Default
	{
		Translation "32:47=219:223", "169:191=213:223";
		BloodColor "Orange";
	}
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_CheckSight("Spawn2");
		TNT1 A 0 A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
		TNT1 A 0 A_TossGib();
		Stop;
	Spawn2:
		TNT1 A 0 A_TossGib();
		Stop;
	}
}

Class OrangeGibSp : GreenGib
{
	Default
	{
		Translation "32:47=219:223", "169:191=213:223";
		BloodColor "Orange";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_CheckSight("Spawn2");
		TNT1 AAAAAAAA 0 
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	Spawn2:
		TNT1 AA 0
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	}
}


//***********************************
Class GrayGib : GibletBaseSpawner
{
	Default
	{
		Translation "32:47=104:111", "169:191=80:106";
		BloodColor "Gray";
	}
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_CheckSight("Spawn2");
		TNT1 AA 0 A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
		Stop;
	Spawn2:
		TNT1 A 0 A_TossGib();
		Stop;
	}
}

Class GrayGibSp : BlueGib
{
	Default
	{
		Translation "32:47=104:111", "169:191=80:106";
		BloodColor "Gray";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_CheckSight("Spawn2");
		TNT1 AAAAAAAA 0 
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	Spawn2:
		TNT1 AA 0
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	}
}

//***********************************
Class PurpleGib : GibletBaseSpawner
{
	Default
	{
		Translation "32:47=254:254", "169:191=253:253";
		BloodColor "Purple";
	}
	States
	{
	Spawn:
		TNT1 A 0;
		TNT1 A 0 A_CheckSight(2);
		TNT1 A 0 A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
		TNT1 A 0 A_TossGib();
		Stop;
	Spawn2:
		TNT1 A 0 A_TossGib();
		Stop;
	}
}

Class PurpleGibSp : GreenGib
{
	Default
	{
		Translation "32:47=254:254", "169:191=253:253";
		BloodColor "Purple";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay A_CheckSight("Spawn2");
		TNT1 AAAAAAAA 0 
		{
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	Spawn2:
		TNT1 A 0
		{
			if (A_CheckProximity("Null","GibletBase",2048,GetCVar("MaxGibCount"),CPXF_ANCESTOR|CPXF_NOZ,Player1))
			{	return ResolveState("Null");	}
			return ResolveState(1);
		}
		TNT1 AA 0
		{
			
			A_SpawnItemEx("NewMeat",0,0,random(10,40),random(-7,7),random(-7,7),random(1,16),random(1,359),GibFlags,0,tid);
			A_TossGib();
		}
		TNT1 A 0 
		{
			A_SpawnItemEx("BloodGib3",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
			A_SpawnItemEx("BloodGib4",0,0,0,random(-7,7),0,0,random(1,359),GibFlags,0,tid);
		}
		Stop;
	}
}