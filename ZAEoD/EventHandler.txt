Class AEoDHandler : EventHandler
{
	bool DemonMorph;
	//Array<uint8> SectorD;
		
	override void NetworkProcess(ConsoleEvent e)
	{	
		if (e.Name == 'EndDemonMorph')
		{
			int num = e.Player;
			let plr = players[num].mo;
			
			if (plr)
			{
				let dm = DemonPlayerMorph(plr);
				if (dm)
				{
					dm.EndMorph();
				}
			}
			return;
		}
		if (!e.IsManual)
		{
			
			if (e.Name == 'DemonMorphOn')
			{
				DemonMorph = true;
				int num = e.Player;
				let plr = players[num].mo;
				
				
				ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
				Actor mo;
				while (mo = Actor(it.Next()))
				{
					if (mo.bISMONSTER && mo.health > 0)
					{
						if (mo.CountInv("DemonMorphTranslationItem") 
							|| mo.Species == 'Director'
							|| mo.Species == 'AEoDSpawner')	continue;
						
						mo.A_GiveInventory("DemonMorphTranslationItem", 1);
					}
				}
			}
			else if (e.Name == 'DemonMorphOff')
			{
				//Console.Printf("Called");
				DemonMorph = false;
				ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
				Actor mo;
				while (mo = Actor(it.Next()))
				{
					let inv = Inventory(mo.FindInventory("DemonMorphTranslationItem"));
					if (inv)	
					{
						//Console.Printf("Attempting Destruction");
						inv.DepleteOrDestroy();
					}
				}
			}
		}
	}
	
	override void WorldUnloaded(WorldEvent e)
	{
		DemonMorph = false;
	}
	
	override void WorldThingSpawned(WorldEvent e)
	{
		if (DemonMorph && e.Thing)
		{
			Actor mo = e.Thing;
			
			if (mo && mo.bISMONSTER && mo.health > 0)
			{
				mo.A_GiveInventory("DemonMorphTranslationItem", 1);
			}
		}
	}
	
	override void WorldThingRevived(WorldEvent e)
	{
		if (DemonMorph && e.Thing)
		{
			Actor mo = e.Thing;
			if (mo && mo.bISMONSTER)
			{
				mo.A_GiveInventory("DemonMorphTranslationItem", 1);
			}
		}
	}
}

Class DemonMorphTransToken : Inventory {}

Class DemonMorphTranslationItem : Inventory
{
	uint OldTranslation;
	uint CurrentTranslation;
	uint FriendlyTranslation;
	uint EnemyTranslation;
	bool wasFriendly;
	bool resurrecting;
	bool DestroyMe;
	bool restored;
	
	override bool TryPickup(in out Actor toucher)
	{
		if (!toucher || toucher.health < 1 || toucher.CountInv(GetClass()))
			return false;
		
		bool good = Super.TryPickup(toucher);
		if (good && toucher)
		{
			restored = false;
			OldTranslation = toucher.Translation;
			toucher.A_SetTranslation("DemonMorphAlly");
			FriendlyTranslation = toucher.Translation;
			toucher.A_SetTranslation("DemonMorphTarget");
			EnemyTranslation = toucher.Translation;
			
			if (toucher.bFRIENDLY)	{ toucher.A_SetTranslation("DemonMorphAlly"); wasFriendly = true; }
			else						toucher.A_SetTranslation("DemonMorphTarget");
			
			toucher.bBRIGHT = true;
			CurrentTranslation = toucher.Translation;
			//Console.Printf("Translation set");
		}
		return good;
	}
	
	//==========================================================================
	//
	// The tick function.
	//
	//==========================================================================
	override void DoEffect()
	{
		// Destroy the thinker if we no actor, or actor's dead.
		if (DestroyMe || !owner || owner.health < 1)
		{
			return DepleteOrDestroy();
		}
		
		// No point doing anything if invisible.
		if (owner.alpha <= 0 || owner.GetRenderStyle() <= 0 || 
			owner.bINVISIBLE || owner.bNOSECTOR)
			return Super.DoEffect();
		
		
		// Change the translation based on friendly or not.
		// Make sure not to record it by changing the base and current
		// at the same time.
		if (!wasFriendly && owner.bFRIENDLY)
		{
			owner.Translation = CurrentTranslation = FriendlyTranslation;
		}
		else if (wasFriendly && !owner.bFRIENDLY)
		{
			owner.Translation = CurrentTranslation = EnemyTranslation;
		}
		wasFriendly = owner.bFRIENDLY;
		
		// Should their translation change at any point, record it.
		if (owner.Translation != CurrentTranslation)
			OldTranslation = owner.Translation;
		
		// Then set it again, and done.
		owner.Translation = CurrentTranslation;
		owner.bBRIGHT = true;
		restored = false;
		Super.DoEffect();
	}
	//==========================================================================
	//
	// As of switching to inventory items, this actually works for
	// monsters that burst into fragments thanks to the special handling of
	// inventory items upon death.
	//
	// Why do we need all three of these functions? Simply put, calling a
	// function is very time critical. This ensures all corner cases are
	// covered and all escape paths are cut off, ensuring the gibs are
	// returned to normal.
	// 
	// For example, OwnerDied in the super function calls Destroy() which then
	// has to process some other stuff first. By this time it may be too late.
	// Because this is all processed in a virtual machine, this is one exception
	// to making a function call for doing the work. It may be tidier, but
	// call speed is imperative if we want things happening in the proper order.
	// 
	//==========================================================================
	override void OwnerDied()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.OwnerDied();
	}
	override void OnDestroy()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.OnDestroy();
	}
	override void DepleteOrDestroy()
	{
		if (owner && !restored)
		{
			owner.Translation = OldTranslation;
			owner.bBRIGHT = false;
			restored = true;
		}
		Super.DepleteOrDestroy();
	}
}