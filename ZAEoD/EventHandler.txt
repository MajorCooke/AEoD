#include "ZAEoD/WeaponSwitch.txt"
#include "ZAEoD/EventMisc.txt"

Class ACSConverter play
{
	static void ToggleDirectors(int on = 0, bool text = false, bool forced = false)
	{
		AEoDHandler.SendNetworkEvent("ToggleDirectors", on, text, forced);
	}
}
Class AEoDHandler : EventHandler
{
	enum EGameMode
	{
		GameMode_Normal = 0,
		GameMode_L4D
	};
	enum ECvarList
	{
		Game_Blood,
		Game_Doom,
		Game_Duke,
		Game_Heretic,
		Game_Hexen,
		Game_Hexen2,
		Game_HL,
		Game_HL2,
		Game_MM,
		Game_Powerslave,
		Game_Quake1,
		Game_Quake2,
		Game_Quake4,
		Game_SW,
		Extra_Dm64,
		Extra_Hellspawn,
		Extra_Joke,
		Extra_L4DMon,
		Extra_ROTT,
		
		GameCount = 10,
		ExtraCount = 5,
		TotalCount = GameCount + ExtraCount
	};
	
	Array<Actor> Monsters, DeadMonsters, Tracker;
	bool DemonMorph;
	bool CvarsUpdated;
	bool DirectorsEnabled, NoDirectors;
	DirectorBase L4DDirector;
	DirectorBase NormalDirector;
	int L4DIntensity, MonIntensity, DirDelay, GameMode, L4DDir, NorDir;
	uint16 GibCount, GibSoft, GibHard;
	
	//Array<uint8> SectorD;	
	transient Cvar 	Themes[TotalCount];
	transient Cvar 	CL4DIntensity, CMonIntensity, CDirDelay, CEnabled, CL4DDir, CNorDir,
					CGameMode;
	transient CVar	CGibSoft, CGibHard;
	//transient Cvar DirCvar[3];
	
	
	void GetCvars()
	{
		/*
		static const String Cvars[] =
		{
			"user_Doom",
			"user_Blood",
			"user_Duke",
			"user_HL",
			"user_HL2",
			"user_Heretic",
			"user_Hexen",
			"user_Hexen2",
			"user_MM",
			"user_Powerslave",
			"user_Quake1",
			"user_Quake2",
			"user_Quake4",
			"user_SW",
			"user_Strife"
			//-------------- The rest below are extras, not themes.
			"user_Dm64", 
			"user_Hellspawn", 
			"user_Joke", 
			"user_L4DMon", 
			"user_ROTT" 
		};
		
		for (int i = 0; i < Themes.Size(); i++)
		{
			
		}
		*/
		if (!CGameMode)			CGameMode = Cvar.FindCvar("AEoDGameMode");
		if (!CL4DIntensity)		CL4DIntensity = Cvar.FindCvar("user_L4DIntensity");
		if (!CMonIntensity)		CMonIntensity = Cvar.FindCvar("user_MonIntensity");
		if (!CDirDelay)			CDirDelay = Cvar.FindCvar("DirectorDelay");
		if (!CNorDir)			CNorDir = Cvar.FindCvar("user_NorDir");
		if (!CL4DDir)			CL4DDir = Cvar.FindCvar("user_L4DDir");
		if (!CGibSoft)			CGibSoft = Cvar.FindCvar("MaxSoftGibCount");
		if (!CGibHard)			CGibHard = Cvar.FindCvar("MaxGibCount");
		
		if (CL4DIntensity)		L4DIntensity = 		CL4DIntensity.GetInt();
		if (CMonIntensity)		MonIntensity = 		CMonIntensity.GetInt();
		if (CDirDelay)			DirDelay = 			CDirDelay.GetInt();
		if (CGameMode)			GameMode =			CGameMode.GetInt();
		if (CNorDir)			NorDir =			CNorDir.GetBool();
		if (CL4DDir)			L4DDir =			CL4DDir.GetBool();
		if (CGibSoft)			GibSoft =			CGibSoft.GetInt();
		if (CGibHard)			GibHard =			CGibHard.GetInt();
	}
	
	override void OnRegister()
	{
		GetCvars();
	}
	
	private uint8 Timer;
	override void WorldTick()
	{
		Timer++;
		if (Timer % 35 <= 0)
		{
			if (!CGibSoft || !CGibHard)
			{
				CGibSoft = Cvar.FindCvar("MaxSoftGibCount");
				CGibHard = Cvar.FindCvar("MaxGibCount");
			}
			if (CGibSoft && CGibHard)
			{
				GibSoft = CGibSoft.GetInt();
				GibHard = CGibHard.GetInt();
			}
		}
		if (Timer >= 350)
		{
			Timer = 0;
			/*
			int i = 0;
			for (i = 0; i < Monsters.Size(); i++)		if (!Monsters[i])		{	Monsters.Delete(i); i--;		}
			for (i = 0; i < DeadMonsters.Size(); i++)	if (!DeadMonsters[i])	{	DeadMonsters.Delete(i); i--;	}
			Monsters.ShrinkToFit();
			DeadMonsters.ShrinkToFit();
			*/
		}
	}
	
	override void WorldLoaded(WorldEvent e)
	{
		GibCount = 0; Timer = 0;
		GetCvars();
		let plr = players[0].mo;
		if (!e.IsReopen && !e.IsSaveGame)
		{
			if (GameMode == 1)
			{
				Actor.Spawn("TheDirectorL4D", plr.pos);
				plr.A_GiveInventory("L4DDirToken");
			}
			else
			{
				if (NorDir)	Actor.Spawn("TheDirector", plr.pos);
				if (L4DDir)	
				{
					Actor.Spawn("TheDirectorL4D", plr.pos);
					plr.A_GiveInventory("L4DDirToken");
				}
			}
			
			DirectorsEnabled = (NorDir || L4DDir);
		}
	}
	
	override void WorldUnloaded(WorldEvent e)
	{
		Monsters.Clear();
		DeadMonsters.Clear();
		GibCount = 0; Timer = 0;
		DemonMorph = CvarsUpdated = false;
		for (int i = 0; i < MAXPLAYERS; i++)
		{
			if (playeringame[i])
			{
				let plr = players[i].mo;
				if (plr)	
				{
					plr.A_SetInventory("RemoveDirector",0);
				}
			}
		}
	}
	
	// Tremendous thanks to Phantombeta for helping me out with this.
	override bool InputProcess(InputEvent ev)
	{
		
		if (ev.Type == InputEvent.Type_KeyDown)// && ev.KeyChar >= 0x30 && ev.KeyChar <= 0x39) // 0x30, 0x39 are '0' and '9'
		{		
			// Make sure the player exists.
			let plr = players[consoleplayer].mo;
			if (!plr || plr.health < 1 || plr.FindInventory("PowerMorph",true))
				// Ignore players that are morphed, dead or non-existent.
				return false;
				
			static const String KeyBindsCCMDs [] = {
				"slot 1", "slot 2", "slot 3", "slot 4", "slot 5",
				"slot 6", "slot 7", "slot 8", "slot 9", "slot 0",
				"weapnext", "weapprev"	};
			static const String KeyBindsNetEvents [] = {
				"slot:1", "slot:2", "slot:3", "slot:4", "slot:5",
				"slot:6", "slot:7", "slot:8", "slot:9", "slot:0",
				"next", "prev"	};
			
			// Find the key and translate it from the raw command to an 
			// event-friendly string. Makes splitting it easier.
			int bind1, bind2;
			for (int i = 0; i < KeyBindsCCMDs.Size(); i++) 
			{
				// Bindings is a global struct. Definition in menu.txt inside GZDoom.pk3.
				// Get the keys that are bound to this action.
				[bind1, bind2] = Bindings.GetKeysForCommand (KeyBindsCCMDs [i]);
				
				if (ev.KeyScan == bind1 || ev.KeyScan == bind2) 
				{
				//	EventHandler.SendNetworkEvent (String.Format ("ScrollWheelHijack:%s", KeyBindsNetEvents [i]));
					EventHandler.SendNetworkEvent(String.Format("AEoD_SelectWeapon:%s", KeyBindsNetEvents[i]));
					return true;
				}
			}
		}
		return false;
	}
	
	override void NetworkProcess(ConsoleEvent e)
	{	
		int num = e.Player;
		let plr = players[num].mo;
		if (!plr)	return;
		
		Array<String> strings;
		e.Name.Split (strings, ":");

		if (strings.Size() > 1)
		{
			if (strings[0] == 'AEoD_SelectWeapon')
				ChangeWeapons(e);
		}
		else if (e.Name == 'ToggleDirectors')
		{
			ToggleDirectors(e.Args[0], e.Args[1], e.Args[2]);
		}
		else if (e.IsManual)
		{	
			// Don't let outside mods try to end the morph.
			// Only if done by console will it allow an abrupt ending.
			if (e.Name == 'EndDemonMorph')
			{
				let dm = DemonPlayerMorph(plr);
				if (dm)
				{
					dm.EndMorph();
				}
			}
		}
		else
		{
			if (e.Name == 'DemonMorphOn')
			{
				ToggleDemonMorphEffect(true);
			}
			else if (e.Name == 'DemonMorphOff')
			{
				ToggleDemonMorphEffect(false);
			}
		}
	}
	
	override void WorldThingSpawned(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (mo is "GibletBase")
		{
			GibCount++;
			return;
		}
		if (!mo || mo.bNOINTERACTION || mo.bNOBLOCKMAP || mo is "DirectorBase" || mo is "AEoDMonsterSpawner")
			return;
		if (mo.bISMONSTER || mo.bSHOOTABLE)
		{
			/*
			if (health > 0)
				if (Monsters.Find(mo) >= Monsters.Size())
					Monsters.Push(mo);
			else if (DeadMonsters.Find(mo) >= DeadMonsters.Size())
				DeadMonsters.Push(mo);
			*/
			// Don't give to things that are always invisible such as the directors
			// or the base monster spawners. Obviously ignore anything with NOINTERACTION
			// since giving that to a monster while alive is just a bad idea.
			if (DemonMorph && mo.bISMONSTER && mo.health > 0)
				mo.A_GiveInventory("DemonMorphTranslationItem", 1);
		}
	}
	
	override void WorldThingDied(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (!mo || mo.bNOINTERACTION || mo.bNOBLOCKMAP || mo is "DirectorBase" || mo is "AEoDMonsterSpawner")
			return;
		
		/*
		if (Monsters.Find(mo) < Monsters.Size())
		{
			DeadMonsters.Push(mo);
			Monsters.Delete(Monsters.Find(mo));
		}
		*/
	}
	
	override void WorldThingRevived(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (mo && mo.bISMONSTER)
		{
			if (DemonMorph)
				mo.A_GiveInventory("DemonMorphTranslationItem", 1);
				
		//	Monsters.Push(mo);
		//	DeadMonsters.Delete(DeadMonsters.Find(mo));
		}
	}
	
	override void WorldThingDestroyed(WorldEvent e)
	{
		Actor mo = e.Thing;
		if (mo is "GibletBase")
			GibCount--;
		/*
		else if (mo.bISMONSTER || mo.bSHOOTABLE)
		{
			Monsters.Delete(Monsters.Find(mo));
			DeadMonsters.Delete(DeadMonsters.Find(mo));
		}
		*/
	}
	
	//==========================================================================
	//==========================================================================
	// Custom Functions
	//==========================================================================
	//==========================================================================
	
	//--------------------------------------------------------------------------
	// Gib Count
	//--------------------------------------------------------------------------
	int GetGibCount()
	{
		return GibCount;
	}
	
	int CheckGibCount()
	{
		if (GibCount > GibHard)	return 0;
		if (GibCount > GibSoft)	return 1;
		return 2;
	}
	
	//==========================================================================
	// ChangeWeapons
	//
	// Sets the forthcoming weapon based on the command sent to it. Applicable
	// commands are:
	// 
	// slot # (0-9)
	// weapnext
	// weapprev
	//==========================================================================
	void ChangeWeapons(ConsoleEvent e) 
	{
		int pnum = e.Player;
		if (!playeringame[pnum])
			return;
			
		PlayerInfo player = players[pnum];

		if (!player) // Return if the player is null
			return;

		Array<String> commandStrings;
		e.Name.Split (commandStrings, ":");
		if (commandStrings.Size() < 2) // Return if the array contains less than two strings
			return;
			
		// At this point, we should have at minimum two strings in this form:
		// [0] = AEoD_SelectWeapon
		// [1] = <command>
		// See InputProcess for the translations (from first to second array)
		
		let ready = player.ReadyWeapon;
		let pending = player.PendingWeapon;
		
		AEoDWeaponIdentifier Finder = new("AEoDWeaponIdentifier");
		Weapon next = null;
		if (commandStrings[1] == 'next')
		{
			next = Weapon(Finder.GetNextWeapon(player, AEoDWeaponIdentifier.Ins_SetNext));
		}
		else if (commandStrings[1] == 'prev')
		{
			next = Weapon(Finder.GetNextWeapon(player, AEoDWeaponIdentifier.Ins_SetPrev));
		}
		else if (commandStrings[1] == 'slot')
		{
			// Switching to a weapon in slot.
			// AEoD_SelectWeapon:slot:#
			// # is what we want for "slot" command.
			int len = (commandStrings.Size() > 2) ? commandStrings[2].Length() : 0;
			if (len < 1)
			{
				Finder.Destroy();
				return;
			}
			
			String s = commandStrings[2];
			if (len > 1)	s = s.CharAt(len - 1);
			int num = s.ToInt();
			if (Finder)
				next = Finder.GetNextWeapon(player, AEoDWeaponIdentifier.Ins_SetSlot, num);
		}
		if (next && next != ready)	player.PendingWeapon = next;
		//else Console.Printf("-2");
		Finder.Destroy();
	}
	//==========================================================================
	// ToggleDirectors
	// 
	// Self explanatory.
	//==========================================================================
	static void GlobalToggleDirectors(int on = 0, bool text = false, bool forced = false)
	{
		AEoDHandler.SendNetworkEvent("ToggleDirectors", on, text, forced);
	}
	
	void ToggleDirectors(int status, bool silent, bool forced = false)
	{
		bool good = (L4DDirector || NormalDirector);
		
		if (!forced)
		{
			if (CGameMode.GetInt() == GameMode_L4D)
			{
				status = 1;
				silent = true;
				Console.Printf("Directors cannot be toggled in this game mode.");
			}
		}
		
		if (good)
		{
			if (status != 1 && status != -1)
				status = (DirectorsEnabled) ? -1 : 1;
			
			Switch (status)
			{
				Default:
					Console.Printf("Report to devs! Error code -111");
					break;
				Case 1:	// Enable
					if (!DirectorsEnabled)
					{
						if (!silent)		Console.Printf("Directors Enabled");
						if (L4DDirector)	L4DDirector.Activate(null);
						if (NormalDirector)	NormalDirector.Activate(null);
						DirectorsEnabled = true;
					}
					break;
				Case -1: // Disable
					if (DirectorsEnabled)
					{
						if (!silent)		Console.Printf("Directors Disabled");
						if (L4DDirector)	L4DDirector.Deactivate(null);
						if (NormalDirector)	NormalDirector.Deactivate(null);
						DirectorsEnabled = false;
					}
					break;
			}
		}
	}
	
	//==========================================================================
	// ToggleDemonMorphEffect
	// 
	// Toggles the Demon Morph effect on monsters. Paints actors:
	// Enemy - 		Orangeish Yellow
	// Friendly - 	Blue
	//==========================================================================
	private void ToggleDemonMorphEffect(bool on)
	{
		if (on)
		{
			DemonMorph = true;
			ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
			Actor mo;
			while (mo = Actor(it.Next()))
			{
				if (mo.bISMONSTER && mo.health > 0)
				{
					if (mo.CountInv("DemonMorphTranslationItem") 
						|| mo.Species == 'Director'
						|| mo.Species == 'AEoDSpawner')	continue;
					
					mo.A_GiveInventory("DemonMorphTranslationItem", 1);
				}
			}
		}
		else
		{
			//Console.Printf("Called");
			DemonMorph = false;
			ThinkerIterator it = ThinkerIterator.Create("Actor", Thinker.STAT_DEFAULT);
			Actor mo;
			while (mo = Actor(it.Next()))
			{
				let inv = Inventory(mo.FindInventory("DemonMorphTranslationItem"));
				if (inv)	
				{
					//Console.Printf("Attempting Destruction");
					inv.DepleteOrDestroy();
				}
			}
		}
	}
}



